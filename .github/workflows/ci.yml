name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  # Generate semantic version for the build
  version:
    name: Generate Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.semver.outputs.semantic_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
        with:
          fetch-depth: 0  # Required for semantic version generation

      - name: Generate semantic version
        id: semver
        uses: lukaszraczylo/semver-generator@3704fdfb2c7ca95f2d20e5a648ccf50c87a37846 # v1
        with:
          config_file: semver.yaml
          repository_local: true
          strict: false
          existing: true

      - name: Display generated version
        run: echo "Generated version:${{ steps.semver.outputs.semantic_version }}"

  test:
    name: Build and Test
    runs-on: macos-latest
    needs: version
    permissions:
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5

      - name: Setup Swift
        uses: swift-actions/setup-swift@682457186b71c25a884c45c06f859febbe259240 # v2

      - name: Show Swift version
        run: swift --version | cat

      - name: Cache SwiftPM build
        uses: actions/cache@0400d5f644dc74513175e3cd8d07132dd4860809 # v4
        with:
          path: .build
          key: ${{ runner.os }}-spm-${{ hashFiles('**/Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-spm-

      - name: Build (debug)
        env:
          AUDIOCAP_VERSION: ${{ needs.version.outputs.version }}
          AUDIOCAP_GIT_COMMIT: ${{ github.sha }}
          AUDIOCAP_BUILD_DATE: ${{ github.event.head_commit.timestamp }}
        run: swift build | cat

      - name: Test (with coverage)
        env:
          AUDIOCAP_VERSION: ${{ needs.version.outputs.version }}
          AUDIOCAP_GIT_COMMIT: ${{ github.sha }}
          AUDIOCAP_BUILD_DATE: ${{ github.event.head_commit.timestamp }}
        run: |
          set -euo pipefail
          swift test --enable-code-coverage

      - name: Generate code coverage report
        run: |
          set -euo pipefail

          # Resolve llvm-cov path (prefer Swift toolchain to match profdata version; fall back to Xcode)
          SWIFT_BIN_DIR="$(dirname "$(which swift)")"
          if [ -x "$SWIFT_BIN_DIR/llvm-cov" ]; then
            LLVM_COV="$SWIFT_BIN_DIR/llvm-cov"
          else
            LLVM_COV="$(xcrun --find llvm-cov 2>/dev/null || true)"
          fi

          if [ -z "${LLVM_COV:-}" ] || ! "$LLVM_COV" --version >/dev/null 2>&1; then
            echo "âš ï¸ Warning: llvm-cov not available; emitting empty coverage to avoid failure" >&2
            : > coverage.lcov
            exit 0
          fi

          # Locate coverage data
          PROFDATA=$(find .build -name "*.profdata" -print -quit || true)

          # Collect all test bundle binaries (macOS) and fall back to any test executables
          TEST_BINS_FILE=$(mktemp)
          # macOS .xctest bundles
          while IFS= read -r bundle; do
            bin=$(find "$bundle/Contents/MacOS" -type f -maxdepth 1 | head -1)
            if [ -n "${bin:-}" ]; then echo "$bin" >> "$TEST_BINS_FILE"; fi
          done < <(find .build -type d -name "*.xctest" | sort)

          # Fallback: plain test executables (Linux or non-bundle layouts)
          if [ ! -s "$TEST_BINS_FILE" ]; then
            find .build -type f -name "*Tests*" -perm -111 | sort >> "$TEST_BINS_FILE" || true
          fi

          if [ -z "${PROFDATA:-}" ] || [ ! -s "$TEST_BINS_FILE" ]; then
            echo "âš ï¸ Warning: Could not locate coverage inputs (profdata or test binaries). Creating empty coverage.lcov to avoid pipeline failure." >&2
            : > coverage.lcov
          else
            echo "Using profdata: $PROFDATA"
            echo "Using test binaries:"
            cat "$TEST_BINS_FILE"
            # Export LCOV, excluding build and test sources from report. If export fails due to format mismatch, fall back to empty coverage
            if ! xargs "$LLVM_COV" export -format="lcov" -instr-profile="$PROFDATA" -ignore-filename-regex=".build|Tests" < "$TEST_BINS_FILE" > coverage.lcov; then
              echo "âš ï¸ Warning: llvm-cov export failed; emitting empty coverage to avoid pipeline failure" >&2
              : > coverage.lcov
            fi
          fi

      - name: Generate Coverage Summary
        run: |
          if [ ! -f coverage.lcov ]; then
            echo "Error: No coverage.lcov file found"
            exit 1
          fi
          
          echo "ðŸ“Š Code Coverage Report" > coverage_summary.md
          echo "" >> coverage_summary.md
          
          # Parse LCOV file for basic metrics
          LINES_FOUND=$(awk -F: '/^LF:/{sum+=$2} END {print sum+0}' coverage.lcov)
          LINES_HIT=$(awk -F: '/^LH:/{sum+=$2} END {print sum+0}' coverage.lcov)
          FUNCTIONS_FOUND=$(awk -F: '/^FNF:/{sum+=$2} END {print sum+0}' coverage.lcov)
          FUNCTIONS_HIT=$(awk -F: '/^FNH:/{sum+=$2} END {print sum+0}' coverage.lcov)
          BRANCHES_FOUND=$(awk -F: '/^BRF:/{sum+=$2} END {print sum+0}' coverage.lcov)
          BRANCHES_HIT=$(awk -F: '/^BRH:/{sum+=$2} END {print sum+0}' coverage.lcov)
          
          if [ "$LINES_FOUND" -gt 0 ]; then
            LINE_COVERAGE=$(echo "scale=1; $LINES_HIT * 100 / $LINES_FOUND" | bc -l)
          else
            LINE_COVERAGE="0.0"
          fi
          
          if [ "$FUNCTIONS_FOUND" -gt 0 ]; then
            FUNCTION_COVERAGE=$(echo "scale=1; $FUNCTIONS_HIT * 100 / $FUNCTIONS_FOUND" | bc -l)
          else
            FUNCTION_COVERAGE="0.0"
          fi
          
          if [ "$BRANCHES_FOUND" -gt 0 ]; then
            BRANCH_COVERAGE=$(echo "scale=1; $BRANCHES_HIT * 100 / $BRANCHES_FOUND" | bc -l)
          else
            BRANCH_COVERAGE="0.0"
          fi
          
          # Determine coverage badge color
          if (( $(echo "$LINE_COVERAGE >= 80" | bc -l) )); then
            BADGE_COLOR="brightgreen"
            STATUS_ICON="âœ…"
          elif (( $(echo "$LINE_COVERAGE >= 60" | bc -l) )); then
            BADGE_COLOR="yellow" 
            STATUS_ICON="âš ï¸"
          else
            BADGE_COLOR="red"
            STATUS_ICON="âŒ"
          fi
          
          echo "| Metric | Coverage | Lines |" >> coverage_summary.md
          echo "|--------|----------|-------|" >> coverage_summary.md
          echo "| $STATUS_ICON **Line Coverage** | **${LINE_COVERAGE}%** | $LINES_HIT / $LINES_FOUND |" >> coverage_summary.md
          echo "| ðŸ”§ **Function Coverage** | **${FUNCTION_COVERAGE}%** | $FUNCTIONS_HIT / $FUNCTIONS_FOUND |" >> coverage_summary.md
          echo "| ðŸŒ¿ **Branch Coverage** | **${BRANCH_COVERAGE}%** | $BRANCHES_HIT / $BRANCHES_FOUND |" >> coverage_summary.md
          echo "" >> coverage_summary.md
          echo "![Coverage Badge](https://img.shields.io/badge/coverage-${LINE_COVERAGE}%25-${BADGE_COLOR})" >> coverage_summary.md

      - name: Update PR Body with Coverage Summary
        if: github.event_name == 'pull_request'
        run: |
          if [ ! -f coverage_summary.md ]; then
            echo "coverage_summary.md not found; skipping"
            exit 0
          fi

          gh pr view ${{ github.event.number }} --json body -q .body > pr_body.md || echo "" > pr_body.md

          {
            echo "<!-- COVERAGE-START -->"
            echo "### ðŸ“Š Code Coverage"
            echo ""
            cat coverage_summary.md
            echo ""
            echo "<!-- COVERAGE-END -->"
          } > coverage_block.md

          if grep -q "<!-- COVERAGE-START -->" pr_body.md; then
            awk 'BEGIN{skip=0} /<!-- COVERAGE-START -->/{skip=1} skip==0{print} /<!-- COVERAGE-END -->/{skip=0}' pr_body.md > pr_body_clean.md
          else
            cp pr_body.md pr_body_clean.md
          fi

          printf "\n\n" >> pr_body_clean.md
          cat coverage_block.md >> pr_body_clean.md

          gh pr edit ${{ github.event.number }} --body-file pr_body_clean.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Test version command
        env:
          AUDIOCAP_VERSION: ${{ needs.version.outputs.version }}
          AUDIOCAP_GIT_COMMIT: ${{ github.sha }}
          AUDIOCAP_BUILD_DATE: ${{ github.event.head_commit.timestamp }}
        run: .build/debug/audiocap-recorder --version

      - name: Upload debug binary artifact
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: audiocap-recorder-debug-${{ github.sha }}
          path: .build/debug/audiocap-recorder
          if-no-files-found: ignore

  build-release:
    name: Build Release Binary
    runs-on: macos-latest
    needs: [version, test]
    outputs:
      version: ${{ needs.version.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5

      - name: Setup Swift
        uses: swift-actions/setup-swift@682457186b71c25a884c45c06f859febbe259240 # v2

      - name: Cache SwiftPM build
        uses: actions/cache@0400d5f644dc74513175e3cd8d07132dd4860809 # v4
        with:
          path: .build
          key: ${{ runner.os }}-spm-${{ hashFiles('**/Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-spm-

      - name: Build (release)
        env:
          AUDIOCAP_VERSION: ${{ needs.version.outputs.version }}
          AUDIOCAP_GIT_COMMIT: ${{ github.sha }}
          AUDIOCAP_BUILD_DATE: ${{ github.event.head_commit.timestamp }}
        run: swift build -c release | cat

      - name: Test release version command
        env:
          AUDIOCAP_VERSION: ${{ needs.version.outputs.version }}
          AUDIOCAP_GIT_COMMIT: ${{ github.sha }}
          AUDIOCAP_BUILD_DATE: ${{ github.event.head_commit.timestamp }}
        run: .build/release/audiocap-recorder --version

      - name: Strip and prepare binary
        run: |
          strip .build/release/audiocap-recorder
          mkdir -p release
          cp .build/release/audiocap-recorder release/audiocap-recorder-${{ needs.version.outputs.version }}-macos
          
      - name: Upload release binary artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: audiocap-recorder-release-${{ needs.version.outputs.version }}
          path: release/audiocap-recorder-${{ needs.version.outputs.version }}-macos
          if-no-files-found: error

  # Create release only on main branch pushes (not PRs)
  # Unified Release Pipeline - Product + Documentation
  unified-release:
    name: Create Unified Release (Product + Docs)
    runs-on: ubuntu-latest
    needs: [version, build-release, generate-docs]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      contents: write
      pages: write
      id-token: write
    outputs:
      release-created: ${{ steps.release.outputs.release-created }}
      tag-name: ${{ steps.release.outputs.tag-name }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5

      - name: Download release binary
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5
        with:
          name: audiocap-recorder-release-${{ needs.version.outputs.version }}
          path: ./release

      - name: Download documentation artifacts
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5
        with:
          name: documentation-${{ needs.version.outputs.version }}
          path: ./docs-artifacts

      - name: Generate comprehensive release notes
        id: release_notes
        run: |
          echo "Creating release notes for version ${{ needs.version.outputs.version }}"
          
          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          
          if [ -n "$LAST_TAG" ]; then
            echo "## ðŸš€ Changes since $LAST_TAG" > release_notes.md
            echo "" >> release_notes.md
            git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges >> release_notes.md
          else
            echo "## ðŸš€ Initial Release" > release_notes.md
            echo "" >> release_notes.md
            echo "First release of audiocap-recorder with semantic versioning and comprehensive documentation." >> release_notes.md
          fi
          
          echo "" >> release_notes.md
          echo "## ðŸŽ¯ Features" >> release_notes.md
          echo "- High-performance macOS audio capture with ScreenCaptureKit" >> release_notes.md
          echo "- Process filtering with regex patterns" >> release_notes.md  
          echo "- Multi-channel input support (up to 8 channels)" >> release_notes.md
          echo "- Multiple compression formats: ALAC, AAC, MP3" >> release_notes.md
          echo "- Professional CLI interface with swift-argument-parser" >> release_notes.md
          echo "" >> release_notes.md
          echo "## ðŸ“– Documentation" >> release_notes.md
          echo "- **[ðŸ“š Complete Documentation](https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/docs/)**" >> release_notes.md
          echo "- **[ðŸš€ Quick Start Guide](https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/docs/QuickStart)**" >> release_notes.md
          echo "- **[ðŸ“‹ API Reference](https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/docs/docc/)**" >> release_notes.md
          echo "- **[ðŸ§ª Code Examples](https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/docs/category/recipes)**" >> release_notes.md
          echo "" >> release_notes.md
          echo "## ðŸ’¾ Installation" >> release_notes.md
          echo "Download the binary, make it executable, and run:" >> release_notes.md
          echo '```bash' >> release_notes.md
          echo 'chmod +x audiocap-recorder-${{ needs.version.outputs.version }}-macos' >> release_notes.md
          echo './audiocap-recorder-${{ needs.version.outputs.version }}-macos --help' >> release_notes.md
          echo '```' >> release_notes.md
          echo "" >> release_notes.md
          echo "## ðŸ”§ Version Information" >> release_notes.md
          echo "- **Product Version:** v${{ needs.version.outputs.version }}" >> release_notes.md
          echo "- **Documentation Version:** v${{ needs.version.outputs.version }}" >> release_notes.md
          echo "- **Build Date:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> release_notes.md

      - name: Create GitHub Release with Product + Documentation
        id: release
        run: |
          # Create the release with both product and documentation
          gh release create "v${{ needs.version.outputs.version }}" \
            --title "ðŸš€ Release v${{ needs.version.outputs.version }} (Product + Documentation)" \
            --notes-file release_notes.md \
            release/audiocap-recorder-${{ needs.version.outputs.version }}-macos
          
          echo "release-created=true" >> $GITHUB_OUTPUT
          echo "tag-name=v${{ needs.version.outputs.version }}" >> $GITHUB_OUTPUT
          
          echo "âœ… Unified release created: v${{ needs.version.outputs.version }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Deploy Version-Specific Documentation
        uses: peaceiris/actions-gh-pages@4f9cc6602d3f66b9c108549d475ec49e8ef4d45e # v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: docs-artifacts/docs-site/build
          destination_dir: docs/v${{ needs.version.outputs.version }}
          enable_jekyll: false

      - name: Update Latest Documentation Alias
        uses: peaceiris/actions-gh-pages@4f9cc6602d3f66b9c108549d475ec49e8ef4d45e # v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: docs-artifacts/docs-site/build
          destination_dir: docs/latest
          enable_jekyll: false

      - name: Deploy Main Documentation
        uses: peaceiris/actions-gh-pages@4f9cc6602d3f66b9c108549d475ec49e8ef4d45e # v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: docs-artifacts/docs-site/build
          destination_dir: docs
          enable_jekyll: false

      - name: Report Unified Release Status
        run: |
          echo "ðŸŽ‰ UNIFIED RELEASE COMPLETED SUCCESSFULLY!"
          echo ""
          echo "ðŸ“¦ Product Release:"
          echo "  - Version: v${{ needs.version.outputs.version }}"
          echo "  - Binary: audiocap-recorder-${{ needs.version.outputs.version }}-macos"
          echo "  - Release URL: https://github.com/${{ github.repository }}/releases/tag/v${{ needs.version.outputs.version }}"
          echo ""
          echo "ðŸ“– Documentation Deployment:"
          echo "  - Main Docs: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/docs/"
          echo "  - Version-Specific: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/docs/v${{ needs.version.outputs.version }}/"
          echo "  - Latest Alias: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/docs/latest/"
          echo "  - API Reference: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/docs/docc/"
          echo ""
          echo "âœ… Product and documentation released together with semantic version v${{ needs.version.outputs.version }}"

  # Documentation jobs - run after main CI passes
  build-examples:
    name: Build Documentation Examples
    runs-on: macos-latest
    needs: [version, test]
    if: success()
    strategy:
      matrix:
        example: 
          - 'Examples/QuickStart'
          - 'Examples/Recipes/MonoRecording'
          - 'Examples/Recipes/AdaptiveBitrate'
    
    steps:
    - name: Checkout
      uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
      
    - name: Setup Swift
      uses: swift-actions/setup-swift@682457186b71c25a884c45c06f859febbe259240 # v2
    
    - name: Cache Swift packages
      uses: actions/cache@0400d5f644dc74513175e3cd8d07132dd4860809 # v4
      with:
        path: |
          .build
          ${{ matrix.example }}/.build
        key: ${{ runner.os }}-examples-${{ hashFiles('**/Package.swift') }}-${{ matrix.example }}
        restore-keys: |
          ${{ runner.os }}-examples-${{ hashFiles('**/Package.swift') }}
          ${{ runner.os }}-examples-
    
    - name: Build example project
      working-directory: ${{ matrix.example }}
      run: |
        echo "Building ${{ matrix.example }}..."
        swift build | cat
        echo "âœ… ${{ matrix.example }} builds successfully"

  analyze-snippets:
    name: Validate Code Snippets
    runs-on: macos-latest
    needs: [version, test]
    if: success()
    
    steps:
    - name: Checkout
      uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
      
    - name: Setup Swift
      uses: swift-actions/setup-swift@682457186b71c25a884c45c06f859febbe259240 # v2
    
    - name: Validate Quick-Start code snippets
      run: |
        echo "ðŸ” Validating code snippets in documentation..."
        
        # Check for Swift syntax in markdown files
        find Docs -name "*.md" -exec grep -l '```swift' {} \; | while read file; do
          echo "Checking Swift snippets in $file"
          # Extract Swift code blocks and validate basic syntax
          awk '/```swift/,/```/ {if (!/```/) print}' "$file" > /tmp/snippet.swift
          if [ -s /tmp/snippet.swift ]; then
            echo "Found Swift code in $file"
            # Basic syntax validation could go here
          fi
        done
        
        echo "âœ… Code snippet validation completed"

  generate-docs:
    name: Generate Documentation
    runs-on: macos-latest
    needs: [version, test, build-examples, analyze-snippets]
    if: success()
    permissions:
      contents: read
    
    steps:
    - name: Checkout
      uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
      with:
        fetch-depth: 0
        
    - name: Setup Swift
      uses: swift-actions/setup-swift@682457186b71c25a884c45c06f859febbe259240 # v2
    
    - name: Setup Node.js
      uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: |
          Tools/DocsIndexer/package.json
          docs-site/package.json
    
    - name: Install dependencies
      run: |
        cd Tools/DocsIndexer && npm install
        cd ../../docs-site && npm install
    
    - name: Create semver.yaml
      run: |
        echo "version: \"${{ needs.version.outputs.version }}\"" > semver.yaml
    
    - name: Generate Swift-DocC documentation  
      run: |
        echo "ðŸ”¨ Generating Swift-DocC API documentation..."
        swift run docgen
        echo "âœ… DocC generation completed"
    
    - name: Index documentation with Lunr.js
      run: |
        echo "ðŸ” Building search index..."
        cd Tools/DocsIndexer
        npm run build-index
        echo "âœ… Search index generated"
    
    - name: Benchmark search performance
      run: |
        echo "âš¡ Testing search performance..."
        cd Tools/DocsIndexer
        npm run bench || echo "âš ï¸ Search benchmark failed, continuing..."
    
    - name: Build Docusaurus site
      run: |
        echo "ðŸ—ï¸ Building documentation site..."
        cd docs-site
        npm run build
        echo "âœ… Documentation site built"
    
    - name: Sanitize filenames for artifact upload
      run: |
        echo "ðŸ§¹ Sanitizing filenames and directory names for cross-platform compatibility..."
        
        # First handle directories (must be done depth-first to avoid path issues)
        find build/docs docs-site/build -name "*:*" -type d | sort -r | while read dir; do
          parent=$(dirname "$dir")
          dirname_only=$(basename "$dir")
          # Replace colons with hyphens
          newname=$(echo "$dirname_only" | sed 's/:/-/g')
          if [ "$dirname_only" != "$newname" ]; then
            echo "Renaming directory: $dirname_only -> $newname"
            mv "$dir" "$parent/$newname"
          fi
        done
        
        # Handle other problematic characters in directories
        find build/docs docs-site/build -name '*"*' -o -name '*<*' -o -name '*>*' -o -name '*|*' -o -name '*\**' -o -name '*?*' -type d | sort -r | while read dir; do
          parent=$(dirname "$dir")
          dirname_only=$(basename "$dir")
          # Replace problematic characters with safe alternatives
          newname=$(echo "$dirname_only" | sed 's/[":><|*?]/-/g')
          if [ "$dirname_only" != "$newname" ]; then
            echo "Renaming directory: $dirname_only -> $newname"
            mv "$dir" "$parent/$newname"
          fi
        done
        
        # Now handle files with problematic characters
        find build/docs docs-site/build -name "*:*" -type f | while read file; do
          dir=$(dirname "$file")
          filename=$(basename "$file")
          # Replace colons with hyphens
          newname=$(echo "$filename" | sed 's/:/-/g')
          if [ "$filename" != "$newname" ]; then
            echo "Renaming file: $filename -> $newname"
            mv "$file" "$dir/$newname"
          fi
        done
        
        # Also handle other problematic characters in files
        find build/docs docs-site/build -name '*"*' -o -name '*<*' -o -name '*>*' -o -name '*|*' -o -name '*\**' -o -name '*?*' -type f | while read file; do
          dir=$(dirname "$file")
          filename=$(basename "$file")
          # Replace problematic characters with safe alternatives
          newname=$(echo "$filename" | sed 's/[":><|*?]/-/g')
          if [ "$filename" != "$newname" ]; then
            echo "Renaming file: $filename -> $newname"
            mv "$file" "$dir/$newname"
          fi
        done
        
        echo "âœ… Filename and directory sanitization completed"

    - name: Upload documentation artifacts
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
      with:
        name: documentation-${{ needs.version.outputs.version }}
        path: |
          build/docs/
          docs-site/build/
        retention-days: 30
    
    - name: Report Documentation Build Status
      run: |
        echo "âœ… Documentation build completed successfully"
        echo "ðŸ“Š Documentation artifacts created:"
        echo "  - Swift-DocC API reference"
        echo "  - Lunr.js search index"
        echo "  - Docusaurus static site"
        echo "  - Version: ${{ needs.version.outputs.version }}"
        echo ""
        echo "ðŸš€ Documentation will be deployed during unified release process"
